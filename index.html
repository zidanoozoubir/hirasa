<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ù†Ø¸Ø§Ù… ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø±Ø§Ø³Ø©</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"
            onload="console.log('SheetJS loaded successfully')"
            onerror="alert('âš ï¸ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ù…ÙƒØªØ¨Ø© SheetJS. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª Ø£Ùˆ Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.')"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: #f4f4f4;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }
        h2, h3 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .controls {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
        }
        .input-group label {
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
            text-align: center;
            font-size: 15px;
        }
        .controls input[type="file"],
        .controls input[type="number"],
        .controls select {
            padding: 10px 12px;
            font-size: 16px;
            border-radius: 8px;
            border: 1px solid #c0c0c0;
            transition: all 0.3s ease;
            cursor: pointer;
            width: auto;
            min-width: 100px;
        }
        .controls button {
            padding: 12px 20px;
            font-size: 17px;
            margin: 10px;
            border-radius: 25px;
            border: none;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            min-width: 150px;
        }
        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .controls button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            background: #cccccc !important;
        }
        .controls button#randomAssignBtn {
            background: linear-gradient(to right, #6dd5ed, #2193b0);
        }
        .controls button#saveDistributionBtn {
            background: linear-gradient(to right, #4CAF50, #81C784);
        }
        .controls button#generateListBtn {
            background: linear-gradient(to right, #FFC107, #FFD54F);
        }
        .controls button#exportDistributionBtn {
            background: linear-gradient(to right, #9C27B0, #BA68C8);
        }
        .controls button#clearCacheBtn {
            background: linear-gradient(to right, #795548, #A1887F);
        }
        /* New button style for Reset Distribution */
        .controls button#resetDistributionBtn {
            background: linear-gradient(to right, #e67e22, #f39c12); /* Orange */
        }

        /* --- New Styles for Filter Controls --- */
        .filter-controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }
        .search-group, .filter-group {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .search-group label, .filter-group label {
            font-weight: bold;
            color: #555;
            white-space: nowrap;
        }
        .filter-controls input[type="text"] {
            padding: 10px;
            font-size: 16px;
            border-radius: 8px;
            border: 1px solid #c0c0c0;
            width: 250px;
            transition: all 0.3s ease;
        }
        .filter-controls select {
            padding: 10px;
            font-size: 16px;
            border-radius: 8px;
            border: 1px solid #c0c0c0;
            cursor: pointer;
            min-width: 150px;
            transition: all 0.3s ease;
        }
        .filter-controls button {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 20px;
            border: none;
            color: white;
            cursor: pointer;
            background: linear-gradient(to right, #f39c12, #f1c40f);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .filter-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        /* --- End New Styles --- */

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-top: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #e0e0e0;
        }
        th, td {
            border: 1px solid #eee;
            padding: 15px;
            text-align: center;
            vertical-align: middle;
            font-size: 15px;
        }
        th {
            background: #4a90e2;
            color: white;
            font-weight: bold;
            border-color: #4a90e2;
        }
        tr:nth-child(even) { background-color: #f6faff; }
        tr:hover { background-color: #eaf3ff; }

        .fixed-guard-row {
            background-color: #ffe0b2 !important;
            font-weight: bold;
            color: #6d4c41;
        }
        /* Removed specific disabled styles for fixed-guard-row inputs as they are now editable */
        /* .fixed-guard-row input[type="text"],
        .fixed-guard-row input[type="checkbox"],
        .fixed-guard-row .reserve-select {
            cursor: not-allowed;
            opacity: 0.7;
        } */

        .main-guard-row {
            background-color: #2196F3 !important;
            color: #FFFFFF;
        }

        .exempt-guard-row {
            background-color: #f7f7f7 !important;
            color: #888;
            text-decoration: line-through;
            opacity: 0.7;
        }
        .exempt-guard-row input:not([type="checkbox"]),
        .exempt-guard-row .reserve-select {
            opacity: 0.5;
            background-color: #f0f0f0;
        }
        .exempt-guard-row input[type="checkbox"] {
            cursor: not-allowed;
        }
        .exempt-guard-row .btn-danger {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .reserve-guard-row {
            background-color: #4CAF50 !important;
            color: #FFFFFF;
            font-style: italic;
        }
        .reserve-guard-row input:not([type="checkbox"]),
        .reserve-guard-row .reserve-select {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f0f0f0;
        }
        .reserve-guard-row input[type="checkbox"] {
            cursor: not-allowed;
        }
        .reserve-guard-row .btn-danger {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input[type="text"], input[type="number"] {
            width: 100px;
            padding: 8px;
            text-align: center;
            border: 1px solid #a0a0a0;
            border-radius: 6px;
            font-size: 15px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        input[type="text"]:focus, input[type="number"]:focus,
        .controls input[type="file"]:focus,
        .controls select:focus,
        .controls button:focus,
        .filter-controls input[type="text"]:focus,
        .filter-controls select:focus,
        .filter-controls button:focus {
            outline: none;
            border-color: #2193b0;
            box-shadow: 0 0 0 3px rgba(33, 147, 176, 0.3);
        }
        input[type="checkbox"] {
            transform: scale(1.3);
            margin: 0 5px;
            cursor: pointer;
        }
        .btn-danger {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s ease;
        }
        .btn-danger:hover { background: #c0392b; }

        #printBtn {
            display: none;
            margin: 30px auto;
            padding: 15px 30px;
            font-size: 19px;
            background: linear-gradient(to right, #4facfe, #00f2fe);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        #printBtn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0 0 0 / 0.25);
        }
        #statusMessage {
            text-align: center;
            padding: 12px;
            margin: 10px auto 20px auto;
            border-radius: 8px;
            font-weight: bold;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            max-width: 600px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .status-success { background-color: #e6ffed; color: #388e3c; border: 1px solid #a5d6a7; }
        .status-error { background-color: #ffebee; color: #d32f2f; border: 1px solid #ef9a9a; }
        .status-info { background-color: #e3f2fd; color: #1976d2; border: 1px solid #90caf9; }
        .status-loading { background-color: #fffde7; color: #fbc02d; border: 1px solid #fff9c4; }

        .reserve-select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #a0a0a0;
            font-size: 15px;
            width: 120px;
            text-align: center;
            appearance: none;
            background-color: white;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20256%20256%22%3E%3Cpath%20fill%3D%22%23666%22%20d%3D%22M128%2C186.2L32%2C90.2h192z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reserve-select:focus {
            outline: none;
            border-color: #2193b0;
            box-shadow: 0 0 0 3px rgba(33, 147, 176, 0.3);
        }

        .reserve-select:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #f0f0f0;
        }
        .reserve-select-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }

        /* New Guard Addition Section Styles */
        .add-guard-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-top: 30px;
            text-align: center;
        }
        .add-guard-section h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #4a90e2;
            border-bottom: none;
        }
        .add-guard-inputs {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        .add-guard-inputs input[type="text"] {
            padding: 10px 12px;
            font-size: 16px;
            border-radius: 8px;
            border: 1px solid #c0c0c0;
            width: 200px;
            max-width: 100%;
        }
        .add-guard-inputs button {
            padding: 12px 20px;
            font-size: 17px;
            border-radius: 25px;
            border: none;
            color: white;
            cursor: pointer;
            background: linear-gradient(to right, #00C9FF, #92FE9D);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .add-guard-inputs button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .input-group, .button-group {
                margin: 0;
                width: 100%;
            }
            .controls button {
                width: 100%;
                margin: 10px 0;
            }
            /* Responsive for filter controls */
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .search-group, .filter-group {
                flex-direction: column;
                align-items: stretch;
            }
            .filter-controls input[type="text"],
            .filter-controls select,
            .filter-controls button {
                width: 100%;
                margin: 5px 0;
            }

            table, th, td {
                font-size: 14px;
                padding: 10px;
            }
            input[type="text"], input[type="number"], .reserve-select {
                width: 80px;
            }
        }

        /* Print Specific Styles */
        @media print {
            html, body {
                width: 100%;
                margin: 0;
                padding: 0;
            }
            body {
                background: none;
                padding: 1cm; /* Adjust overall padding for print */
                margin: 0;
                color: black;
                font-size: 11pt; /* Slightly smaller base font for more content */
            }
            .controls, .filter-controls, .add-guard-section, #statusMessage, #printBtn {
                display: none; /* Hide UI elements not relevant for print */
            }
            h2, h3 {
                border-bottom: none;
                margin-top: 20px;
                margin-bottom: 10px;
                font-size: 16pt; /* Slightly smaller heading for print */
                page-break-after: avoid; /* Keep heading with table below */
                padding-bottom: 0; /* Remove underline for print */
            }
            #guardsTable, #finalGuardsTable, #reserveGuardsTable {
                box-shadow: none;
                padding: 0;
                margin-top: 0;
                overflow: visible; /* Allow content to overflow if necessary, handled by page-break */
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
                margin-bottom: 20px; /* Space between tables */
                border: 1px solid #aaa; /* Clearer table borders */
            }
            th, td {
                border: 1px solid #ccc;
                padding: 6px 8px; /* Reduced padding for more content */
                text-align: right;
                font-size: 9pt; /* Smaller font for table cells */
            }
            th {
                background-color: #e0e0e0; /* Light background for headers */
                color: #333;
                font-weight: bold;
            }
            tr {
                page-break-inside: avoid; /* Keep table rows together */
            }
            /* Ensure background colors are transparent for print */
            .fixed-guard-row, .main-guard-row, .exempt-guard-row, .reserve-guard-row {
                background-color: transparent !important;
                color: black !important;
                text-decoration: none !important;
                font-weight: normal !important; /* Reset font weight for clarity */
                font-style: normal !important; /* Reset font style */
            }
            /* Remove explicit page-break-after for main table, allow natural flow */
            #finalGuardsTable {
                margin-bottom: 30px; /* Space after the main table */
            }
            #reserveGuardsTable {
                margin-top: 20px; /* Space before reserve table */
            }
        }
    </style>
</head>
<body>

<h2>ğŸ“‹ Ù†Ø¸Ø§Ù… ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø±Ø§Ø³Ø© - Ø§Ø³ØªÙŠØ±Ø§Ø¯ ÙˆØªÙˆØ²ÙŠØ¹</h2>
<div id="statusMessage"></div>
<div class="controls">
    <div class="input-group">
        <label for="excelFile">Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù Excel</label>
        <input type="file" id="excelFile" accept=".xlsx,.xls" />
    </div>

    <div class="input-group">
        <label for="roomCount">Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ø§Ø¹Ø§Øª</label>
        <input type="number" id="roomCount" value="5" min="1" />
    </div>

    <div class="input-group">
        <label for="guardsPerRoom">Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø±Ø§Ø³ ÙÙŠ Ù‚Ø§Ø¹Ø©</label>
        <input type="number" id="guardsPerRoom" value="3" min="1" />
    </div>

    <div class="input-group">
        <label for="periodSelect">Ø§Ù„ÙØªØ±Ø©</label>
        <select id="periodSelect"></select>
    </div>

    <div class="button-group">
        <button id="randomAssignBtn">ğŸ”€ ØªÙˆØ²ÙŠØ¹ Ø¹Ø´ÙˆØ§Ø¦ÙŠ</button>
        <button id="resetDistributionBtn">â†©ï¸ Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªÙˆØ²ÙŠØ¹</button>
        <button id="saveDistributionBtn">ğŸ“‚ Ø­ÙØ¸ Ø§Ù„ØªÙˆØ²ÙŠØ¹</button>
        <button id="generateListBtn">ğŸ“‹ Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
        <button id="exportDistributionBtn">ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ù„ØªÙˆØ²ÙŠØ¹</button>
        <button id="clearCacheBtn">ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø­Ù„ÙŠØ©</button>
    </div>
</div>

<div class="filter-controls">
    <div class="search-group">
        <label for="searchGuardInput">Ø¨Ø­Ø« Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ Ø§Ù„Ù…Ø§Ø¯Ø©:</label>
        <input type="text" id="searchGuardInput" placeholder="Ø§ÙƒØªØ¨ Ù„Ù„Ø¨Ø­Ø«..." />
        <button id="clearSearchBtn">Ù…Ø³Ø­ Ø§Ù„Ø¨Ø­Ø«</button>
    </div>
    <div class="filter-group">
        <label for="filterRank">Ø§Ù„Ø±ØªØ¨Ø©:</label>
        <select id="filterRank">
            <option value="">Ø§Ù„ÙƒÙ„</option>
        </select>
        <label for="filterSubject">Ø§Ù„Ù…Ø§Ø¯Ø©:</label>
        <select id="filterSubject">
            <option value="">Ø§Ù„ÙƒÙ„</option>
        </select>
        <label for="filterInstitution">Ø§Ù„Ù…Ø¤Ø³Ø³Ø©:</label>
        <select id="filterInstitution">
            <option value="">Ø§Ù„ÙƒÙ„</option>
        </select>
    </div>
</div>
<table id="guardsTable">
    <thead>
    <tr>
        <th>Ø§Ù„Ø±Ù‚Ù…</th>
        <th>Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨</th>
        <th>Ø§Ù„Ù…Ø§Ø¯Ø©</th>
        <th>Ø§Ù„Ø±ØªØ¨Ø©</th>
        <th>Ø§Ù„Ù…Ø¤Ø³Ø³Ø©</th>
        <th>Ø±Ù‚Ù… Ø§Ù„Ù‚Ø§Ø¹Ø©</th>
        <th>Ø±Ø¦ÙŠØ³ÙŠ</th>
        <th>ØªØ«Ø¨ÙŠØª</th>
        <th>Ù…Ø¹ÙÙ‰</th>
        <th>Ø§Ø­ØªÙŠØ§Ø·ÙŠ</th>
        <th>Ø­Ø°Ù</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<div class="add-guard-section">
    <h3>â• Ø¥Ø¶Ø§ÙØ© Ø­Ø§Ø±Ø³ Ø¬Ø¯ÙŠØ¯ ÙŠØ¯ÙˆÙŠØ§Ù‹:</h3>
    <div class="add-guard-inputs">
        <input type="text" id="newGuardName" placeholder="Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨" required>
        <input type="text" id="newGuardSubject" placeholder="Ø§Ù„Ù…Ø§Ø¯Ø©" required>
        <input type="text" id="newGuardRank" placeholder="Ø§Ù„Ø±ØªØ¨Ø©">
        <input type="text" id="newGuardInstitution" placeholder="Ø§Ù„Ù…Ø¤Ø³Ø³Ø©">
        <button id="addGuardBtn">Ø¥Ø¶Ø§ÙØ© Ø­Ø§Ø±Ø³</button>
    </div>
</div>

<h3>âœ… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø±Ø§Ø³Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:</h3>
<table id="finalGuardsTable"></table>

<h3>âš ï¸ Ø§Ù„Ø­Ø±Ø§Ø³ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠÙˆÙ†:</h3>
<table id="reserveGuardsTable"></table>

<button id="printBtn" onclick="printTable()">ğŸš¶ï¸ Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</button>

<script>
    const IDS = {
        EXCEL_FILE: "excelFile",
        ROOM_COUNT: "roomCount",
        GUARDS_PER_ROOM: "guardsPerRoom",
        PERIOD_SELECT: "periodSelect",
        RANDOM_ASSIGN_BTN: "randomAssignBtn",
        SAVE_DISTRIBUTION_BTN: "saveDistributionBtn",
        GENERATE_LIST_BTN: "generateListBtn",
        EXPORT_DISTRIBUTION_BTN: "exportDistributionBtn",
        GUARDS_TABLE: "guardsTable",
        FINAL_GUARDS_TABLE: "finalGuardsTable",
        RESERVE_GUARDS_TABLE: "reserveGuardsTable",
        PRINT_BTN: "printBtn",
        STATUS_MESSAGE: "statusMessage",
        CLEAR_CACHE_BTN: "clearCacheBtn",
        // New IDs for filters
        SEARCH_GUARD_INPUT: "searchGuardInput",
        CLEAR_SEARCH_BTN: "clearSearchBtn",
        FILTER_RANK: "filterRank",
        FILTER_SUBJECT: "filterSubject",
        FILTER_INSTITUTION: "filterInstitution",
        // New ID for reset distribution
        RESET_DISTRIBUTION_BTN: "resetDistributionBtn",
        // IDs for manual guard addition (re-introduced based on earlier conversation)
        ADD_GUARD_BTN: 'addGuardBtn',
        NEW_GUARD_NAME: 'newGuardName',
        NEW_GUARD_SUBJECT: 'newGuardSubject',
        NEW_GUARD_RANK: 'newGuardRank',
        NEW_GUARD_INSTITUTION: 'newGuardInstitution',
    };

    const MESSAGES = {
        SHEETJS_LOAD_ERROR: 'âš ï¸ Ù…ÙƒØªØ¨Ø© SheetJS ØºÙŠØ± Ù…ØªØ§Ø­Ø©. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª Ø£Ùˆ Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.',
        FILE_NOT_SELECTED: 'âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Excel.',
        EXCEL_READ_ERROR: 'âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù Excel. ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙŠØºØ© Ø§Ù„Ù…Ù„Ù.',
        MISSING_FIELDS: (fields) => `âš ï¸ Ù…Ù„Ù Excel ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©: ${fields.join(", ")}`,
        IMPORT_SUCCESS: 'âœ… ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù Excel Ø¨Ù†Ø¬Ø§Ø­',
        PERIOD_CHANGED: (period) => `âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„ÙØªØ±Ø© Ø¥Ù„Ù‰ ${period}`,
        ASSIGN_ERROR: 'âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ.',
        NOT_ENOUGH_GUARDS: (available, required) => `âš ï¸ Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø±Ø§Ø³ Ø§Ù„Ù…ØªØ§Ø­ÙŠÙ† (${available}) Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (${required}).`,
        NOT_ENOUGH_MAIN_GUARDS: (available, required) => `âš ï¸ Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø±Ø§Ø³ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­ÙŠÙ† (${available}) Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (${required}) Ù„ØªØºØ·ÙŠØ© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø§Ø¹Ø§Øª.`,
        TOO_MANY_MAIN_GUARDS_MANUAL: (roomCount) => `âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¹ÙŠÙŠÙ† Ø£ÙƒØ«Ø± Ù…Ù† ${roomCount} Ø­Ø±Ø§Ø³ Ø±Ø¦ÙŠØ³ÙŠÙŠÙ†. ÙŠØ±Ø¬Ù‰ Ø¥Ù„ØºØ§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø­Ø§Ø±Ø³ Ø±Ø¦ÙŠØ³ÙŠ Ø¢Ø®Ø± Ø£ÙˆÙ„Ø§Ù‹.`,
        TOO_MANY_MAIN_GUARDS_IN_ROOM: (roomNumber) => `âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ø±Ø³ÙŠÙ† Ø±Ø¦ÙŠØ³ÙŠÙŠÙ† ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø© ${roomNumber}. ÙŠØ±Ø¬Ù‰ Ø¥Ù„ØºØ§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø­Ø§Ø±Ø³ Ø±Ø¦ÙŠØ³ÙŠ Ø¢Ø®Ø± Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø§Ø¹Ø©.`,
        UNASSIGNED_GUARD: (name) => `âš ï¸ ÙØ´Ù„ ÙÙŠ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø§Ø±Ø³ ${name} Ø¨Ø³Ø¨Ø¨ Ù‚ÙŠÙˆØ¯ Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø£Ùˆ Ø¹Ø¯Ù… ÙƒÙØ§ÙŠØ© Ø§Ù„Ù‚Ø§Ø¹Ø§Øª.`,
        UNFILLED_ROOMS: (rooms) => `âš ï¸ Ø§Ù„Ù‚Ø§Ø¹Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ù„Ù… ØªÙÙ…Ù„Ø£ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„:\n${rooms.join("\n")}`,
        RANDOM_ASSIGN_SUCCESS: "âœ… ØªÙ… Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨Ù†Ø¬Ø§Ø­",
        ROOM_INPUT_ERROR: "âš ï¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‚Ø§Ø¹Ø© ØµØ­ÙŠØ­.",
        FIX_ROOM_REQUIRED: "âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø±Ù‚Ù… Ù‚Ø§Ø¹Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ«Ø¨ÙŠØª.",
        MAIN_ROOM_REQUIRED: "âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø±Ù‚Ù… Ù‚Ø§Ø¹Ø© Ù„Ù„Ø­Ø§Ø±Ø³ Ù‚Ø¨Ù„ ØªØ¹ÙŠÙŠÙ†Ù‡ ÙƒØ±Ø¦ÙŠØ³ÙŠ.",
        GUARD_DELETED: (name) => `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø­Ø§Ø±Ø³ ${name}`,
        SAVE_SUCCESS: (period) => `âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­ Ù„Ù„ÙØªØ±Ø© ${period}`,
        GENERATE_LIST_SUCCESS: "âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­",
        EXPORT_SUCCESS: "âœ… ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­",
        PRINT_OPEN: "âœ… ØªÙ… ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©",
        GENERIC_ERROR: "âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø³Ø¬Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡.",
        LOADING_IMPORT: "Ø¬Ø§Ø±Ù Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù Excel...",
        LOADING_ASSIGN: "Ø¬Ø§Ø±Ù ØªÙ†ÙÙŠØ° Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ...",
        LOADING_EXPORT: "Ø¬Ø§Ø±Ù ØªØµØ¯ÙŠØ± Ø§Ù„ØªÙˆØ²ÙŠØ¹...",
        LOADING_PRINT: "Ø¬Ø§Ø±Ù Ø¥Ø¹Ø¯Ø§Ø¯ ØµÙØ­Ø© Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©...",
        CLEAR_CACHE_CONFIRM: "Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø­Ù„ÙŠØ§Ù‹ØŸ Ù‡Ø°Ø§ Ø³ÙŠØ¹ÙŠØ¯ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¥Ù„Ù‰ Ø­Ø§Ù„ØªÙ‡ Ø§Ù„Ø£ØµÙ„ÙŠØ© ÙˆØ³ÙŠØªØ·Ù„Ø¨ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù Excel.",
        CLEAR_CACHE_SUCCESS: "âœ… ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø­Ù„ÙŠØ§Ù‹ ÙˆØ¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© Ø¨Ù†Ø¬Ø§Ø­.",
        RESERVE_GUARD_ENABLED: (name) => `âœ… ØªÙ… Ø¬Ø¹Ù„ Ø§Ù„Ø­Ø§Ø±Ø³ ${name} Ø§Ø­ØªÙŠØ§Ø·ÙŠØ§Ù‹.`,
        RESERVE_GUARD_DISABLED: (name) => `âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø§Ù„Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù„Ø­Ø§Ø±Ø³ ${name}.`,
        RESET_DISTRIBUTION_CONFIRM: "Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„ÙŠØŸ Ø³ÙŠØ¤Ø¯ÙŠ Ù‡Ø°Ø§ Ø¥Ù„Ù‰ Ù…Ø³Ø­ Ø§Ù„Ù‚Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ù…Ø¹ÙÙ‰ ÙˆØ§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø±Ø§Ø³ Ø¥Ù„Ù‰ Ø­Ø§Ù„ØªÙ‡Ù… Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©ØŒ Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØ«Ø¨ÙŠØªØ§Øª.",
        RESET_DISTRIBUTION_SUCCESS: "âœ… ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¨Ù†Ø¬Ø§Ø­.",
        ADD_GUARD_SUCCESS: 'âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø§Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­.',
        ADD_GUARD_ERROR: 'âŒ ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø­Ù‚Ù„ Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨ ÙˆØ§Ù„Ù…Ø§Ø¯Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ø­Ø§Ø±Ø³.',
    };

    let allGuards = []; // Current guards for the active period
    let baseGuards = []; // Original guards loaded from Excel
    let distributions = {}; // Stores distributions for each period
    let currentPeriod = 1;
    const TOTAL_PERIODS = 11;
    // Renamed globalMainFixedMap to globalFixedAssignments for clarity
    let globalFixedAssignments = {}; // Stores fixed assignments across all periods (Name -> RoomNumber)

    let autoSaveTimer; // Declare autoSaveTimer
    const AUTO_SAVE_INTERVAL = 30 * 1000; // 30 seconds

    document.addEventListener("DOMContentLoaded", function() {
        console.log('DOM Content Loaded');
        loadSettingsFromLocalStorage();
        initializePeriodSelect();
        attachEventListeners();
        updateGuardsTable();
        populateFilterOptions(); // Populate filter options on load
        startAutoSave(); // Start auto-save
    });

    function loadSettingsFromLocalStorage() {
        try {
            const storedRoomCount = localStorage.getItem('roomCount');
            const storedGuardsPerRoom = localStorage.getItem('guardsPerRoom');
            const storedCurrentPeriod = localStorage.getItem('currentPeriod');
            // Updated to use the new variable name
            const storedFixedAssignments = localStorage.getItem('globalFixedAssignments'); 
            const storedDistributions = localStorage.getItem('distributions');
            const storedBaseGuards = localStorage.getItem('baseGuards');

            if (storedRoomCount) document.getElementById(IDS.ROOM_COUNT).value = storedRoomCount;
            if (storedGuardsPerRoom) document.getElementById(IDS.GUARDS_PER_ROOM).value = storedGuardsPerRoom;
            if (storedCurrentPeriod) currentPeriod = parseInt(storedCurrentPeriod);
            // Updated to use the new variable name
            if (storedFixedAssignments) globalFixedAssignments = JSON.parse(storedFixedAssignments); 
            if (storedDistributions) distributions = JSON.parse(storedDistributions);
            if (storedBaseGuards) baseGuards = JSON.parse(storedBaseGuards);

            if (distributions[currentPeriod]) {
                allGuards = JSON.parse(JSON.stringify(distributions[currentPeriod]));
            } else {
                allGuards = JSON.parse(JSON.stringify(baseGuards));
            }

            // Ensure fixed guards retain their properties when loading
            allGuards.forEach(g => {
                if (globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]) {
                    g["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                    // Do not automatically set 'Ø±Ø¦ÙŠØ³ÙŠ' or clear 'Ù…Ø¹ÙÙ‰'/'Ø§Ø­ØªÙŠØ§Ø·ÙŠ' here
                    // The 'fixed-guard-row' class will visually indicate it's fixed.
                    // If they are fixed, they cannot be exempt or reserve at that moment.
                    if (g["Ù…Ø¹ÙÙ‰"]) {
                        g["Ù…Ø¹ÙÙ‰"] = false;
                        setStatusMessage(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¥Ø¹ÙØ§Ø¡ Ø§Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} Ù„Ø£Ù†Ù‡ Ù…Ø«Ø¨Øª.`, "info", 5000);
                    }
                    if (g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]) {
                        g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false;
                        setStatusMessage(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø§Ù„Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} Ù„Ø£Ù†Ù‡ Ù…Ø«Ø¨Øª.`, "info", 5000);
                    }
                }
            });

        } catch (error) {
            console.error("Error loading settings from local storage:", error);
            setStatusMessage("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©.", "error", 5000);
        }
    }

    function saveSettingsToLocalStorage() {
        try {
            localStorage.setItem('roomCount', document.getElementById(IDS.ROOM_COUNT).value);
            localStorage.setItem('guardsPerRoom', document.getElementById(IDS.GUARDS_PER_ROOM).value);
            localStorage.setItem('currentPeriod', currentPeriod);
            // Updated to use the new variable name
            localStorage.setItem('globalFixedAssignments', JSON.stringify(globalFixedAssignments)); 
            localStorage.setItem('distributions', JSON.stringify(distributions));
            localStorage.setItem('baseGuards', JSON.stringify(baseGuards));
        } catch (error) {
            console.error("Error saving settings to local storage:", error);
            setStatusMessage("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.", "error", 5000);
        }
    }

    function startAutoSave() {
        if (autoSaveTimer) {
            clearInterval(autoSaveTimer);
        }
        autoSaveTimer = setInterval(() => {
            if (allGuards.length > 0) {
                saveCurrentDistribution(); // Use saveCurrentDistribution to also update period distribution
                console.log("Auto-saved distribution.");
            }
        }, AUTO_SAVE_INTERVAL);
    }

    function initializePeriodSelect() {
        const periodSelect = document.getElementById(IDS.PERIOD_SELECT);
        periodSelect.innerHTML = '';
        for (let i = 1; i <= TOTAL_PERIODS; i++) {
            let option = document.createElement("option");
            option.value = i;
            option.textContent = `Ø§Ù„ÙØªØ±Ø© ${i}`;
            periodSelect.appendChild(option);
        }
        periodSelect.value = currentPeriod;
    }

    function attachEventListeners() {
        const excelFileInput = document.getElementById(IDS.EXCEL_FILE);
        if (excelFileInput) {
            excelFileInput.addEventListener("change", importExcel);
        } else {
            console.error("Ø§Ù„Ø¹Ù†ØµØ± excelFile ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ DOM.");
            setStatusMessage("âš ï¸ Ø®Ø·Ø£ Ø¯Ø§Ø®Ù„ÙŠ: Ø¹Ù†ØµØ± Ø¥Ø¯Ø®Ø§Ù„ Ù…Ù„Ù Excel Ù…ÙÙ‚ÙˆØ¯.", "error");
        }
        
        document.getElementById(IDS.PERIOD_SELECT).addEventListener("change", changePeriod);
        document.getElementById(IDS.ROOM_COUNT).addEventListener("change", saveSettingsToLocalStorage);
        document.getElementById(IDS.GUARDS_PER_ROOM).addEventListener("change", saveSettingsToLocalStorage);

        document.getElementById(IDS.RANDOM_ASSIGN_BTN).addEventListener("click", assignRandomly);
        document.getElementById(IDS.SAVE_DISTRIBUTION_BTN).addEventListener("click", saveCurrentDistribution);
        document.getElementById(IDS.GENERATE_LIST_BTN).addEventListener("click", generateFinalList);
        document.getElementById(IDS.EXPORT_DISTRIBUTION_BTN).addEventListener("click", exportDistribution);
        
        const clearCacheBtn = document.getElementById(IDS.CLEAR_CACHE_BTN);
        if (clearCacheBtn) {
            clearCacheBtn.addEventListener("click", clearCacheAndLocalStorage);
        } else {
            console.error("Ø§Ù„Ø¹Ù†ØµØ± clearCacheBtn ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ DOM.");
        }

        // New event listener for Reset Distribution button
        const resetDistributionBtn = document.getElementById(IDS.RESET_DISTRIBUTION_BTN);
        if (resetDistributionBtn) {
            resetDistributionBtn.addEventListener("click", resetCurrentDistribution);
        } else {
            console.error("Ø§Ù„Ø¹Ù†ØµØ± resetDistributionBtn ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ DOM.");
        }

        // Event listeners for filter controls
        document.getElementById(IDS.SEARCH_GUARD_INPUT).addEventListener("input", applyFilters);
        document.getElementById(IDS.CLEAR_SEARCH_BTN).addEventListener("click", function() {
            document.getElementById(IDS.SEARCH_GUARD_INPUT).value = "";
            applyFilters();
        });
        document.getElementById(IDS.FILTER_RANK).addEventListener("change", applyFilters);
        document.getElementById(IDS.FILTER_SUBJECT).addEventListener("change", applyFilters);
        document.getElementById(IDS.FILTER_INSTITUTION).addEventListener("change", applyFilters);

        // Event listener for adding new guard manually
        document.getElementById(IDS.ADD_GUARD_BTN).addEventListener('click', addNewGuard);
    }

    function setStatusMessage(message, type = "info", duration = 3000) {
        const statusMessageDiv = document.getElementById(IDS.STATUS_MESSAGE);
        if (!statusMessageDiv) {
            console.error("Ø§Ù„Ø¹Ù†ØµØ± statusMessage ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ DOM.");
            return;
        }
        statusMessageDiv.textContent = message;
        statusMessageDiv.className = '';
        statusMessageDiv.classList.add(
            type === 'success' ? 'status-success' :
            type === 'error' ? 'status-error' :
            type === 'loading' ? 'status-loading' :
            'status-info'
        );
        statusMessageDiv.style.display = 'block';
        statusMessageDiv.style.opacity = '1';

        if (type !== 'loading') {
            setTimeout(() => {
                statusMessageDiv.style.opacity = '0';
                setTimeout(() => { statusMessageDiv.style.display = 'none'; }, 500);
            }, duration);
        }
    }

    async function importExcel(event) {
        setStatusMessage(MESSAGES.LOADING_IMPORT, "loading");
        if (!window.XLSX) {
            setStatusMessage(MESSAGES.SHEETJS_LOAD_ERROR, "error");
            return;
        }
        const file = event.target.files[0];
        if (!file) {
            setStatusMessage(MESSAGES.FILE_NOT_SELECTED, "error");
            return;
        }

        try {
            const data = await readFileAsync(file);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const json = XLSX.utils.sheet_to_json(sheet);

            const requiredFields = ["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨", "Ø§Ù„Ù…Ø§Ø¯Ø©", "Ø§Ù„Ø±ØªØ¨Ø©", "Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"];
            const firstRow = json[0] || {};
            const missingFields = requiredFields.filter(field => !(field in firstRow));

            if (missingFields.length > 0) {
                setStatusMessage(MESSAGES.MISSING_FIELDS(missingFields), "error", 6000);
                return;
            }

            baseGuards = json.map(row => ({
                ...row,
                "Ø§Ù„Ù‚Ø§Ø¹Ø©": "",
                "Ø±Ø¦ÙŠØ³ÙŠ": false,
                "Ù…Ø¹ÙÙ‰": false,
                "Ø§Ø­ØªÙŠØ§Ø·ÙŠ": false
            }));
            
            allGuards = JSON.parse(JSON.stringify(baseGuards));
            distributions = {}; // Clear distributions on new import
            currentPeriod = 1;
            document.getElementById(IDS.PERIOD_SELECT).value = currentPeriod;

            // Apply fixed guards from globalFixedAssignments to newly imported data
            allGuards.forEach(g => {
                if (globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]) {
                    g["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                    // Do not automatically set 'Ø±Ø¦ÙŠØ³ÙŠ' here when applying fixed assignments
                    g["Ù…Ø¹ÙÙ‰"] = false; // Fixed guards cannot be exempt or reserve
                    g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false;
                }
            });

            saveSettingsToLocalStorage();
            populateFilterOptions(); // Populate filter options after import
            applyFilters(); // Apply filters to update the displayed table
            setStatusMessage(MESSAGES.IMPORT_SUCCESS, "success");
            console.log('Excel imported successfully', allGuards);

        } catch (error) {
            console.error('Error importing Excel:', error);
            setStatusMessage(MESSAGES.EXCEL_READ_ERROR, "error", 6000);
        }
    }

    function readFileAsync(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(new Uint8Array(e.target.result));
            reader.onerror = (e) => reject(e);
            reader.readAsArrayBuffer(file);
        });
    }

    function changePeriod() {
        currentPeriod = parseInt(document.getElementById(IDS.PERIOD_SELECT).value);
        saveSettingsToLocalStorage();

        if (distributions[currentPeriod]) {
            allGuards = JSON.parse(JSON.stringify(distributions[currentPeriod]));
        } else {
            allGuards = JSON.parse(JSON.stringify(baseGuards));
        }

        // Re-apply fixed guards after loading period distribution
        allGuards.forEach(g => {
            if (globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]) {
                g["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                // Do not automatically set 'Ø±Ø¦ÙŠØ³ÙŠ' here when loading fixed guards
                if (g["Ù…Ø¹ÙÙ‰"]) {
                    g["Ù…Ø¹ÙÙ‰"] = false;
                    setStatusMessage(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¥Ø¹ÙØ§Ø¡ Ø§Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} Ù„Ø£Ù†Ù‡ Ù…Ø«Ø¨Øª.`, "info", 5000);
                }
                if (g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]) {
                    g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false;
                    setStatusMessage(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø§Ù„Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} Ù„Ø£Ù†Ù‡ Ù…Ø«Ø¨Øª.`, "info", 5000);
                }
            }
        });
        populateFilterOptions(); // Re-populate filter options for new period's data
        applyFilters(); // Re-apply filters to refresh the table
        setStatusMessage(MESSAGES.PERIOD_CHANGED(currentPeriod), "info");
    }

    function populateFilterOptions() {
        const ranks = new Set();
        const subjects = new Set();
        const institutions = new Set();

        baseGuards.forEach(g => {
            if (g["Ø§Ù„Ø±ØªØ¨Ø©"]) ranks.add(g["Ø§Ù„Ø±ØªØ¨Ø©"]);
            if (g["Ø§Ù„Ù…Ø§Ø¯Ø©"]) subjects.add(g["Ø§Ù„Ù…Ø§Ø¯Ø©"]);
            if (g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]) institutions.add(g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]);
        });

        const filterRank = document.getElementById(IDS.FILTER_RANK);
        const filterSubject = document.getElementById(IDS.FILTER_SUBJECT);
        const filterInstitution = document.getElementById(IDS.FILTER_INSTITUTION);

        function addOptions(selectElement, optionsSet) {
            const currentValue = selectElement.value; // Store current selected value
            selectElement.innerHTML = '<option value="">Ø§Ù„ÙƒÙ„</option>';
            Array.from(optionsSet).sort().forEach(option => {
                const opt = document.createElement("option");
                opt.value = option;
                opt.textContent = option;
                selectElement.appendChild(opt);
            });
            // Try to restore previous selection if it still exists
            if (Array.from(optionsSet).includes(currentValue) || currentValue === "") {
                selectElement.value = currentValue;
            } else {
                selectElement.value = ""; // Reset if current value is no longer valid
            }
        }

        addOptions(filterRank, ranks);
        addOptions(filterSubject, subjects);
        addOptions(filterInstitution, institutions);
    }

    function applyFilters() {
        const searchTerm = document.getElementById(IDS.SEARCH_GUARD_INPUT).value.toLowerCase();
        const selectedRank = document.getElementById(IDS.FILTER_RANK).value;
        const selectedSubject = document.getElementById(IDS.FILTER_SUBJECT).value;
        const selectedInstitution = document.getElementById(IDS.FILTER_INSTITUTION).value;

        const filteredGuards = allGuards.filter(g => {
            const matchesSearch = (g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"] || "").toLowerCase().includes(searchTerm) ||
                                  (g["Ø§Ù„Ù…Ø§Ø¯Ø©"] || "").toLowerCase().includes(searchTerm);
            const matchesRank = selectedRank === "" || g["Ø§Ù„Ø±ØªØ¨Ø©"] === selectedRank;
            const matchesSubject = selectedSubject === "" || g["Ø§Ù„Ù…Ø§Ø¯Ø©"] === selectedSubject;
            const matchesInstitution = selectedInstitution === "" || g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"] === selectedInstitution;

            return matchesSearch && matchesRank && matchesSubject && matchesInstitution;
        });

        updateGuardsTable(filteredGuards);
    }

    function assignRandomly() {
        setStatusMessage(MESSAGES.LOADING_ASSIGN, "loading");
        const roomCount = parseInt(document.getElementById(IDS.ROOM_COUNT).value);
        const guardsPerRoom = parseInt(document.getElementById(IDS.GUARDS_PER_ROOM).value);

        if (baseGuards.length === 0) {
            setStatusMessage("âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù Ø§Ù„Ø­Ø±Ø§Ø³ Ø£ÙˆÙ„Ø§Ù‹.", "error");
            return;
        }

        // Start with a clean slate for assignment for non-fixed, non-exempt, non-reserve guards
        let workingGuards = JSON.parse(JSON.stringify(allGuards)); // Deep copy for manipulation
        
        // Initialize room assignments structure
        const roomAssignments = {};
        for (let i = 1; i <= roomCount; i++) {
            roomAssignments[i] = [];
        }

        let nonAssignedGuards = [];
        let currentMainGuardsCount = 0; // Track assigned main guards

        // 1. Prioritize assigning FIXED guards first, maintaining their properties
        workingGuards.forEach(guard => {
            if (globalFixedAssignments[guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]) {
                const fixedRoom = parseInt(globalFixedAssignments[guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]);
                // Ensure room is valid and not yet full
                if (fixedRoom >= 1 && fixedRoom <= roomCount && roomAssignments[fixedRoom].length < guardsPerRoom) {
                    // Re-add to the room and retain its properties (Ø§Ù„Ù‚Ø§Ø¹Ø©, Ø±Ø¦ÙŠØ³ÙŠ)
                    roomAssignments[fixedRoom].push(guard);
                    if (guard["Ø±Ø¦ÙŠØ³ÙŠ"]) { // Count only if it was already marked as main
                        currentMainGuardsCount++;
                    }
                } else {
                    // If fixed guard's room is invalid or full, treat as unassigned for now
                    nonAssignedGuards.push(guard);
                }
            } else if (!guard["Ù…Ø¹ÙÙ‰"] && !guard["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]) {
                // For non-fixed, non-exempt, non-reserve guards, clear their assignment for random distribution
                guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = "";
                guard["Ø±Ø¦ÙŠØ³ÙŠ"] = false;
                nonAssignedGuards.push(guard);
            } else {
                // Exempt and reserve guards are already excluded from assignment logic
                // If they were somehow assigned, clear their room/main status
                guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = "";
                guard["Ø±Ø¦ÙŠØ³ÙŠ"] = false;
            }
        });

        shuffleArray(nonAssignedGuards); // Shuffle only the truly assignable guards

        // 2. Fill remaining main guard slots from nonAssignedGuards, prioritizing different institutions
        for (let room = 1; room <= roomCount; room++) {
            const hasMainGuard = roomAssignments[room].some(g => g["Ø±Ø¦ÙŠØ³ÙŠ"]);
            if (!hasMainGuard && roomAssignments[room].length < guardsPerRoom) {
                if (currentMainGuardsCount < roomCount) {
                    let chosenGuardIndex = -1;
                    const institutionsInRoom = new Set(roomAssignments[room].map(g => g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]));

                    // Try to find a main guard from a different institution among nonAssignedGuards
                    chosenGuardIndex = nonAssignedGuards.findIndex(g => !institutionsInRoom.has(g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]));

                    // If no main guard from different institution, take the first available nonAssignedGuard
                    if (chosenGuardIndex === -1 && nonAssignedGuards.length > 0) {
                        chosenGuardIndex = 0;
                    }

                    if (chosenGuardIndex !== -1) {
                        const mainGuard = nonAssignedGuards.splice(chosenGuardIndex, 1)[0];
                        mainGuard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = room.toString();
                        mainGuard["Ø±Ø¦ÙŠØ³ÙŠ"] = true; // Mark as main
                        roomAssignments[room].push(mainGuard);
                        currentMainGuardsCount++;
                    }
                }
            }
        }
        
        if (currentMainGuardsCount < roomCount) {
             setStatusMessage(MESSAGES.NOT_ENOUGH_MAIN_GUARDS(currentMainGuardsCount, roomCount), "info", 8000);
        }

        // 3. Fill remaining slots from nonAssignedGuards, prioritizing different institutions
        for (let room = 1; room <= roomCount; room++) {
            while (roomAssignments[room].length < guardsPerRoom && nonAssignedGuards.length > 0) {
                let chosenGuardIndex = -1;
                const institutionsInRoom = new Set(roomAssignments[room].map(g => g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]));

                // Try to find a guard from a different institution among nonAssignedGuards
                chosenGuardIndex = nonAssignedGuards.findIndex(g => !institutionsInRoom.has(g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]));
                
                // If no guard from different institution, take the first available nonAssignedGuard
                if (chosenGuardIndex === -1 && nonAssignedGuards.length > 0) {
                    chosenGuardIndex = 0;
                }

                if (chosenGuardIndex !== -1) {
                    const guardToAssign = nonAssignedGuards.splice(chosenGuardIndex, 1)[0];
                    guardToAssign["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = room.toString();
                    guardToAssign["Ø±Ø¦ÙŠØ³ÙŠ"] = false; // Ensure they are not main unless explicitly set
                    roomAssignments[room].push(guardToAssign);
                }
            }
        }

        // 4. Update allGuards with the new assignments and manage reserves/exempts
        const assignedNames = new Set();
        Object.values(roomAssignments).forEach(roomGuards => {
            roomGuards.forEach(guard => {
                // Find the original guard object in allGuards and update its properties
                const originalGuard = allGuards.find(g => g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"] === guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]);
                if (originalGuard) {
                    originalGuard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"];
                    originalGuard["Ø±Ø¦ÙŠØ³ÙŠ"] = guard["Ø±Ø¦ÙŠØ³ÙŠ"];
                    originalGuard["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false; // If assigned, cannot be reserve
                    assignedNames.add(guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]);
                }
            });
        });

        // Any guard in `allGuards` that wasn't assigned (and isn't fixed, exempt, or explicitly reserve)
        // should become a reserve. Fixed guards remain as they are.
        allGuards.forEach(guard => {
            if (!assignedNames.has(guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]) && !globalFixedAssignments[guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]] && !guard["Ù…Ø¹ÙÙ‰"]) {
                guard["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = true;
                guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = "";
                guard["Ø±Ø¦ÙŠØ³ÙŠ"] = false;
            } else if (!assignedNames.has(guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]) && globalFixedAssignments[guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]) {
                 // If a fixed guard's room was invalid/full and thus not assigned, they remain as fixed
                 // in their originally specified room in globalFixedAssignments for the next load/manipulation.
                 // They should not become reserve.
                 guard["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false; // Ensure they are not marked as reserve if fixed
                 guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = globalFixedAssignments[guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]; // Keep their fixed room
                 // If fixed and not assigned, they will simply not appear in the final list for this distribution.
            }
        });
        
        const unfilledRooms = Object.entries(roomAssignments)
            .filter(([, guards]) => guards.length < guardsPerRoom)
            .map(([room, guards]) => `Ø§Ù„Ù‚Ø§Ø¹Ø© ${room} (Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø±Ø§Ø³: ${guards.length}/${guardsPerRoom})`)
            .join("\n");

        if (unfilledRooms.length > 0) {
            setStatusMessage(MESSAGES.UNFILLED_ROOMS(unfilledRooms), "info", 8000);
        } else {
             setStatusMessage(MESSAGES.RANDOM_ASSIGN_SUCCESS, "success");
        }
        
        applyFilters(); // Use applyFilters to update table after assignment
        saveCurrentDistribution();
    }

    function updateGuardsTable(guardsToDisplay = allGuards) {
        const tbody = document.querySelector(`#${IDS.GUARDS_TABLE} tbody`);
        if (!tbody) {
            console.error("Ø§Ù„Ø¹Ù†ØµØ± guardsTable tbody ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ DOM.");
            return;
        }
        
        const fragment = document.createDocumentFragment();

        guardsToDisplay.forEach((g_filtered, i_filtered) => {
            const originalIndex = allGuards.findIndex(guard => guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"] === g_filtered["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]);
            
            if (originalIndex === -1) {
                console.warn(`Guard ${g_filtered["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} not found in allGuards during display update.`);
                return;
            }

            const g = allGuards[originalIndex];
            const isFixed = !!globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];

            const row = document.createElement("tr");

            if (g["Ù…Ø¹ÙÙ‰"]) {
                row.classList.add("exempt-guard-row");
            } else if (g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]) {
                row.classList.add("reserve-guard-row");
            } else if (isFixed) { // Check for fixed status using the new variable
                row.classList.add("fixed-guard-row");
            } else if (g["Ø±Ø¦ÙŠØ³ÙŠ"]) {
                row.classList.add("main-guard-row");
            }

            const numCell = document.createElement("td");
            numCell.textContent = i_filtered + 1; 
            row.appendChild(numCell);

            const fields = ["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨", "Ø§Ù„Ù…Ø§Ø¯Ø©", "Ø§Ù„Ø±ØªØ¨Ø©", "Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"];
            fields.forEach(field => {
                const cell = document.createElement("td");
                cell.textContent = g[field] || "";
                row.appendChild(cell);
            });

            const roomCell = document.createElement("td");
            const roomInput = document.createElement("input");
            roomInput.type = "text";
            roomInput.value = g["Ø§Ù„Ù‚Ø§Ø¹Ø©"] || "";
            // Room input is disabled only if exempt or reserve, but NOT if fixed.
            roomInput.disabled = g["Ù…Ø¹ÙÙ‰"] || g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"];
            roomInput.addEventListener("change", function() {
                const value = this.value.trim();
                // If it's a fixed guard and room changed, update the fixed assignment
                if (isFixed && value && /^\d+$/.test(value)) {
                    globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]] = value;
                } else if (isFixed && !value) {
                     // If fixed guard removes room, also remove from fixed assignments
                    delete globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                }

                if (value && !/^\d+$/.test(value)) {
                    setStatusMessage(MESSAGES.ROOM_INPUT_ERROR, "error");
                    this.value = allGuards[originalIndex]["Ø§Ù„Ù‚Ø§Ø¹Ø©"] || "";
                    return;
                }
                allGuards[originalIndex]["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = value;
                saveCurrentDistribution();
                applyFilters(); // Re-apply filters to update visual classification
            });
            roomCell.appendChild(roomInput);
            row.appendChild(roomCell);

            const mainCell = document.createElement("td");
            const mainCheckbox = document.createElement("input");
            mainCheckbox.type = "checkbox";
            mainCheckbox.checked = g["Ø±Ø¦ÙŠØ³ÙŠ"];
            // Main checkbox is disabled only if exempt or reserve
            mainCheckbox.disabled = g["Ù…Ø¹ÙÙ‰"] || g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"];

            mainCheckbox.addEventListener("change", function() {
                const roomCount = parseInt(document.getElementById(IDS.ROOM_COUNT).value);
                const targetRoom = allGuards[originalIndex]["Ø§Ù„Ù‚Ø§Ø¹Ø©"];

                if (this.checked) {
                    if (!targetRoom) {
                        setStatusMessage(MESSAGES.MAIN_ROOM_REQUIRED, "error", 5000);
                        this.checked = false;
                        return;
                    }
                    
                    const mainGuardInTargetRoom = allGuards.some((guard, idx) => 
                        idx !== originalIndex && guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] === targetRoom && guard["Ø±Ø¦ÙŠØ³ÙŠ"] && !guard["Ù…Ø¹ÙÙ‰"]
                    );

                    if (mainGuardInTargetRoom) {
                        setStatusMessage(MESSAGES.TOO_MANY_MAIN_GUARDS_IN_ROOM(targetRoom), "error", 7000);
                        this.checked = false;
                        return;
                    }
                    
                    const currentMainGuardsGlobal = allGuards.filter(guard => 
                        guard["Ø±Ø¦ÙŠØ³ÙŠ"] && !guard["Ù…Ø¹ÙÙ‰"] && guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"] !== g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]
                    ).length;

                    if (currentMainGuardsGlobal + 1 > roomCount) {
                        setStatusMessage(MESSAGES.TOO_MANY_MAIN_GUARDS_MANUAL(roomCount), "error", 5000);
                        this.checked = false;
                        return;
                    }
                }
                
                allGuards[originalIndex]["Ø±Ø¦ÙŠØ³ÙŠ"] = this.checked;
                saveCurrentDistribution();
                applyFilters(); // Re-apply filters to update visual classification
            });
            mainCell.appendChild(mainCheckbox);
            row.appendChild(mainCell);

            const fixCell = document.createElement("td");
            const fixCheckbox = document.createElement("input");
            fixCheckbox.type = "checkbox";
            fixCheckbox.checked = isFixed; // Use the isFixed flag
            // Fixed checkbox is disabled only if exempt or reserve
            fixCheckbox.disabled = g["Ù…Ø¹ÙÙ‰"] || g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"];
            fixCheckbox.addEventListener("change", function() {
                if (this.checked) {
                    if (!allGuards[originalIndex]["Ø§Ù„Ù‚Ø§Ø¹Ø©"]) {
                        setStatusMessage(MESSAGES.FIX_ROOM_REQUIRED, "error");
                        this.checked = false;
                        return;
                    }
                    // When a guard is fixed, they cannot be exempt or reserve
                    if (allGuards[originalIndex]["Ù…Ø¹ÙÙ‰"]) {
                        allGuards[originalIndex]["Ù…Ø¹ÙÙ‰"] = false;
                        setStatusMessage(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¥Ø¹ÙØ§Ø¡ Ø§Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} Ù„Ø£Ù†Ù‡ Ù…Ø«Ø¨Øª.`, "info", 5000);
                    }
                    if (allGuards[originalIndex]["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]) {
                        allGuards[originalIndex]["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false;
                        setStatusMessage(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø§Ù„Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} Ù„Ø£Ù†Ù‡ Ù…Ø«Ø¨Øª.`, "info", 5000);
                    }

                    globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]] = allGuards[originalIndex]["Ø§Ù„Ù‚Ø§Ø¹Ø©"];
                    // DO NOT automatically set 'Ø±Ø¦ÙŠØ³ÙŠ' here
                } else {
                    delete globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                    // DO NOT automatically set 'Ø±Ø¦ÙŠØ³ÙŠ' to false here
                }
                saveSettingsToLocalStorage(); // Save the fixed assignments
                applyFilters(); // Re-apply filters to update visual classification
                saveCurrentDistribution(); // Save the current distribution which might include changes due to fixed status
            });
            fixCell.appendChild(fixCheckbox);
            row.appendChild(fixCell);

            const exemptCell = document.createElement("td");
            const exemptCheckbox = document.createElement("input");
            exemptCheckbox.type = "checkbox";
            exemptCheckbox.checked = g["Ù…Ø¹ÙÙ‰"];
            // Exempt checkbox is disabled if fixed or reserve
            exemptCheckbox.disabled = isFixed || g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]; 
            exemptCheckbox.addEventListener("change", function() {
                allGuards[originalIndex]["Ù…Ø¹ÙÙ‰"] = this.checked;
                if (this.checked) {
                    // If exempt, remove from fixed and set room/main/reserve to false
                    if (isFixed) {
                        delete globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                        saveSettingsToLocalStorage();
                    }
                    allGuards[originalIndex]["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = "";
                    allGuards[originalIndex]["Ø±Ø¦ÙŠØ³ÙŠ"] = false;
                    allGuards[originalIndex]["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false;
                    setStatusMessage(`âœ… ØªÙ… Ø¬Ø¹Ù„ Ø§Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]} Ù…Ø¹ÙÙ‰.`, "success");
                } else {
                     setStatusMessage(`âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø§Ù„Ø© Ø§Ù„Ø¥Ø¹ÙØ§Ø¡ Ù„Ù„Ø­Ø§Ø±Ø³ ${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]}.`, "info");
                }
                applyFilters(); // Re-apply filters to update visual classification
                saveCurrentDistribution();
            });
            exemptCell.appendChild(exemptCheckbox);
            row.appendChild(exemptCell);

            const reserveCell = document.createElement("td");
            reserveCell.classList.add("reserve-select-cell");

            const reserveSelect = document.createElement("select");
            reserveSelect.className = "reserve-select";

            const optionNo = document.createElement("option");
            optionNo.value = "false";
            optionNo.textContent = "ØºÙŠØ± Ø§Ø­ØªÙŠØ§Ø·ÙŠ";
            reserveSelect.appendChild(optionNo);

            const optionYes = document.createElement("option");
            optionYes.value = "true";
            optionYes.textContent = "Ø§Ø­ØªÙŠØ§Ø·ÙŠ";
            reserveSelect.appendChild(optionYes);

            reserveSelect.value = g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] ? "true" : "false";
            // Reserve select is disabled if fixed or exempt
            reserveSelect.disabled = isFixed || g["Ù…Ø¹ÙÙ‰"];
            reserveSelect.addEventListener("change", function() {
                const isReserve = this.value === "true";
                allGuards[originalIndex]["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = isReserve;

                if (isReserve) {
                    allGuards[originalIndex]["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = "";
                    allGuards[originalIndex]["Ø±Ø¦ÙŠØ³ÙŠ"] = false;
                    // If reserve, remove from fixed and exempt
                    if (isFixed) {
                        delete globalFixedAssignments[g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                        saveSettingsToLocalStorage();
                    }
                    allGuards[originalIndex]["Ù…Ø¹ÙÙ‰"] = false;
                    setStatusMessage(MESSAGES.RESERVE_GUARD_ENABLED(g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]), "success");
                } else {
                    setStatusMessage(MESSAGES.RESERVE_GUARD_DISABLED(g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]), "info");
                }
                applyFilters(); // Re-apply filters to update visual classification
                saveCurrentDistribution();
            });
            reserveCell.appendChild(reserveSelect);
            row.appendChild(reserveCell);

            const deleteCell = document.createElement("td");
            const deleteButton = document.createElement("button");
            deleteButton.className = "btn-danger";
            deleteButton.textContent = "ğŸ—‘ï¸";
            // Allow deletion only if not fixed, not exempt, and not reserve
            deleteButton.disabled = isFixed || g["Ù…Ø¹ÙÙ‰"] || g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"];
            deleteButton.addEventListener("click", () => {
                if (confirm(MESSAGES.GUARD_DELETED(g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]) + " Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø°ÙØŸ")) {
                    deleteGuard(originalIndex);
                }
            });
            deleteCell.appendChild(deleteButton);
            row.appendChild(deleteCell);

            fragment.appendChild(row);
        });

        tbody.innerHTML = "";
        tbody.appendChild(fragment);
    }

    function deleteGuard(index) {
        const guardName = allGuards[index]["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"];
        
        allGuards.splice(index, 1);

        baseGuards = baseGuards.filter(g => g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"] !== guardName);

        for (const period in distributions) {
            if (distributions.hasOwnProperty(period)) {
                distributions[period] = distributions[period].filter(g => g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"] !== guardName);
            }
        }
        
        // Updated to use the new variable name
        delete globalFixedAssignments[guardName]; 
        
        saveSettingsToLocalStorage();
        populateFilterOptions(); // Update filter options after deleting a guard
        applyFilters(); // Re-apply filters to update the displayed table
        setStatusMessage(MESSAGES.GUARD_DELETED(guardName), "success");
    }

    // New Function: Reset Current Distribution
    function resetCurrentDistribution() {
        if (confirm(MESSAGES.RESET_DISTRIBUTION_CONFIRM)) {
            // Revert allGuards to the state of baseGuards, but clear distribution specific properties
            allGuards = JSON.parse(JSON.stringify(baseGuards)); // Deep copy to ensure independence
            allGuards.forEach(guard => {
                // Keep fixed guard properties, reset others
                // Updated to use the new variable name
                if (globalFixedAssignments[guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]]) {
                    guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = globalFixedAssignments[guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]];
                    // Do not reset 'Ø±Ø¦ÙŠØ³ÙŠ' for fixed guards here. Let it retain its state if set manually.
                    guard["Ù…Ø¹ÙÙ‰"] = false;
                    guard["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false;
                } else {
                    guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"] = "";
                    guard["Ø±Ø¦ÙŠØ³ÙŠ"] = false;
                    guard["Ù…Ø¹ÙÙ‰"] = false;
                    guard["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"] = false;
                }
            });

            // Remove the current period's distribution from `distributions` if it exists
            if (distributions[currentPeriod]) {
                delete distributions[currentPeriod];
            }

            updateGuardsTable();
            generateFinalList(); // Clear final lists display and regenerate if needed
            saveCurrentDistribution(); // Save this cleared state
            setStatusMessage(MESSAGES.RESET_DISTRIBUTION_SUCCESS, 'success');
        }
    }


    function saveCurrentDistribution() {
        distributions[currentPeriod] = JSON.parse(JSON.stringify(allGuards));
        saveSettingsToLocalStorage();
        setStatusMessage(MESSAGES.SAVE_SUCCESS(currentPeriod), "success");
    }

    function generateFinalList() {
        const finalTable = document.getElementById(IDS.FINAL_GUARDS_TABLE);
        const reserveTable = document.getElementById(IDS.RESERVE_GUARDS_TABLE);
        if (!finalTable || !reserveTable) {
            console.error("Ø£Ø­Ø¯ Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©/Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…ÙÙ‚ÙˆØ¯ ÙÙŠ DOM.");
            setStatusMessage("âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©. Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©.", "error");
            return;
        }

        const assignedGuards = allGuards.filter(g => g["Ø§Ù„Ù‚Ø§Ø¹Ø©"] && !g["Ù…Ø¹ÙÙ‰"] && !g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]);
        const reserveGuards = allGuards.filter(g => g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]);

        reserveGuards.sort((a, b) => a["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"].localeCompare(b["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]));

        assignedGuards.sort((a, b) => {
            const roomA = parseInt(a["Ø§Ù„Ù‚Ø§Ø¹Ø©"]);
            const roomB = parseInt(b["Ø§Ù„Ù‚Ø§Ø¹Ø©"]);
            if (roomA !== roomB) return roomA - roomB;
            return (b["Ø±Ø¦ÙŠØ³ÙŠ"] ? -1 : 0) - (a["Ø±Ø¦ÙŠØ³ÙŠ"] ? -1 : 0); // Main guards first within a room
        });

        const groupedByRoom = assignedGuards.reduce((acc, guard) => {
            const room = guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"];
            if (!acc[room]) {
                acc[room] = [];
            }
            acc[room].push(guard);
            return acc;
        }, {});

        let finalTableHtml = `<thead><tr><th>Ø§Ù„Ù‚Ø§Ø¹Ø©</th><th>Ø§Ù„Ø­Ø§Ø±Ø³ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ</th>`;
        const guardsPerRoom = parseInt(document.getElementById(IDS.GUARDS_PER_ROOM).value);
        for(let i = 2; i <= guardsPerRoom; i++) {
            finalTableHtml += `<th>Ø§Ù„Ø­Ø§Ø±Ø³ ${i}</th>`;
        }
        finalTableHtml += `</tr></thead><tbody>`;

        const sortedRooms = Object.keys(groupedByRoom).sort((a, b) => parseInt(a) - parseInt(b));

        sortedRooms.forEach(room => {
            const guardsInRoom = groupedByRoom[room];
            finalTableHtml += `<tr><td>${room}</td>`;
            for (let i = 0; i < guardsPerRoom; i++) {
                finalTableHtml += `<td>${guardsInRoom[i]?.["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"] || ""}</td>`;
            }
            finalTableHtml += `</tr>`;
        });
        finalTableHtml += `</tbody>`;
        finalTable.innerHTML = finalTableHtml;

        let reserveTableHtml = `<thead><tr><th>Ø§Ù„Ø±Ù‚Ù…</th><th>Ø§Ù„Ø§Ø³Ù…</th><th>Ø§Ù„Ù…Ø§Ø¯Ø©</th><th>Ø§Ù„Ø±ØªØ¨Ø©</th><th>Ø§Ù„Ù…Ø¤Ø³Ø³Ø©</th></tr></thead><tbody>`;
        reserveGuards.forEach((g, index) => {
            reserveTableHtml += `<tr><td>${index + 1}</td><td>${g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]}</td><td>${g["Ø§Ù„Ù…Ø§Ø¯Ø©"]}</td><td>${g["Ø§Ù„Ø±ØªØ¨Ø©"]}</td><td>${g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]}</td></tr>`;
        });
        reserveTableHtml += `</tbody>`;
        reserveTable.innerHTML = reserveTableHtml;

        document.getElementById(IDS.PRINT_BTN).style.display = "block";
        setStatusMessage(MESSAGES.GENERATE_LIST_SUCCESS, "success");
    }

    function exportDistribution() {
        setStatusMessage(MESSAGES.LOADING_EXPORT, "loading");
        if (!window.XLSX) {
            setStatusMessage(MESSAGES.SHEETJS_LOAD_ERROR, "error");
            return;
        }

        const assignedGuards = allGuards.filter(g => g["Ø§Ù„Ù‚Ø§Ø¹Ø©"] && !g["Ù…Ø¹ÙÙ‰"] && !g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]);
        const reserveGuards = allGuards.filter(g => g["Ø§Ø­ØªÙŠØ§Ø·ÙŠ"]);
        
        reserveGuards.sort((a, b) => a["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"].localeCompare(b["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]));

        assignedGuards.sort((a, b) => {
            const roomA = parseInt(a["Ø§Ù„Ù‚Ø§Ø¹Ø©"]);
            const roomB = parseInt(b["Ø§Ù„Ù‚Ø§Ø¹Ø©"]);
            if (roomA !== roomB) return roomA - roomB;
            return (b["Ø±Ø¦ÙŠØ³ÙŠ"] ? -1 : 0) - (a["Ø±Ø¦ÙŠØ³ÙŠ"] ? -1 : 0);
        });

        const groupedByRoomForExport = assignedGuards.reduce((acc, guard) => {
            const room = guard["Ø§Ù„Ù‚Ø§Ø¹Ø©"];
            if (!acc[room]) {
                acc[room] = [];
            }
            acc[room].push(guard["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"]);
            return acc;
        }, {});

        const guardsPerRoom = parseInt(document.getElementById(IDS.GUARDS_PER_ROOM).value);
        let headerRow = ["Ø§Ù„Ù‚Ø§Ø¹Ø©", "Ø§Ù„Ø­Ø§Ø±Ø³ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ"];
        for(let i = 2; i <= guardsPerRoom; i++) {
            headerRow.push(`Ø§Ù„Ø­Ø§Ø±Ø³ ${i}`);
        }

        const wsData = [
            ["Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø±Ø§Ø³Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© - Ø§Ù„ÙØªØ±Ø© " + currentPeriod],
            [],
            headerRow,
            ...Object.entries(groupedByRoomForExport).sort(([rA], [rB]) => parseInt(rA) - parseInt(rB))
                .map(([room, guards]) => {
                    let row = [room];
                    for(let i = 0; i < guardsPerRoom; i++) {
                        row.push(guards[i] || "");
                    }
                    return row;
                }),
            [],
            ["Ø§Ù„Ø­Ø±Ø§Ø³ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠÙˆÙ†"],
            ["Ø§Ù„Ø§Ø³Ù…", "Ø§Ù„Ù…Ø§Ø¯Ø©", "Ø§Ù„Ø±ØªØ¨Ø©", "Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"],
            ...reserveGuards.map(g => [g["Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨"], g["Ø§Ù„Ù…Ø§Ø¯Ø©"], g["Ø§Ù„Ø±ØªØ¨Ø©"], g["Ø§Ù„Ù…Ø¤Ø³Ø³Ø©"]])
        ];

        const ws = XLSX.utils.aoa_to_sheet(wsData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø±Ø§Ø³Ø©");
        XLSX.writeFile(wb, `ØªÙˆØ²ÙŠØ¹_Ø§Ù„Ø­Ø±Ø§Ø³Ø©_Ø§Ù„ÙØªØ±Ø©_${currentPeriod}.xlsx`);
        setStatusMessage(MESSAGES.EXPORT_SUCCESS, "success");
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function printTable() {
        setStatusMessage(MESSAGES.LOADING_PRINT, "loading");
        const finalTable = document.getElementById(IDS.FINAL_GUARDS_TABLE);
        const reserveTable = document.getElementById(IDS.RESERVE_GUARDS_TABLE);

        if (!finalTable || !reserveTable) {
            setStatusMessage("âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©. Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©.", "error");
            return;
        }

        const finalTableHtml = finalTable.outerHTML;
        const reserveTableHtml = reserveTable.outerHTML;

        const printWindow = window.open("", "_blank", "width=900,height=700,scrollbars=yes");
        if (!printWindow) {
            setStatusMessage("âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©. Ù‚Ø¯ ØªÙƒÙˆÙ† Ø§Ù„Ù†ÙˆØ§ÙØ° Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© Ù…Ø­Ø¸ÙˆØ±Ø©.", "error");
            return;
        }

        printWindow.document.write(`
            <!DOCTYPE html>
            <html lang="ar" dir="rtl">
            <head>
                <meta charset="UTF-8">
                <title>Ø·Ø¨Ø§Ø¹Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø±Ø§Ø³Ø©</title>
                <style>
                    html, body {
                        width: 100%;
                        margin: 0;
                        padding: 0;
                    }
                    body { 
                        font-family: 'Arial', sans-serif; 
                        margin: 1cm; /* Adjust overall padding for print */
                        color: black;
                        font-size: 11pt; /* Slightly smaller base font for more content */
                        direction: rtl; /* Ensure RTL for print */
                    }
                    h2, h3 { 
                        text-align: center; 
                        color: #333; 
                        margin-bottom: 10px; 
                        margin-top: 20px;
                        font-size: 16pt; /* Slightly smaller heading for print */
                        page-break-after: avoid; /* Keep heading with table below */
                    }
                    table { 
                        width: 100%; 
                        border-collapse: collapse; 
                        margin-bottom: 20px; /* Space between tables */
                        border: 1px solid #aaa; /* Clearer table borders */
                        page-break-inside: auto; /* Allow table to break across pages if necessary */
                    }
                    th, td { 
                        border: 1px solid #ccc; 
                        padding: 6px 8px; /* Reduced padding for more content */
                        text-align: right; 
                        font-size: 9pt; /* Smaller font for table cells */
                    }
                    th { 
                        background-color: #e0e0e0; /* Light background for headers */
                        color: #333;
                        font-weight: bold;
                    }
                    tr {
                        page-break-inside: avoid; /* Keep table rows together */
                        page-break-after: auto; /* Allow natural break after row */
                    }
                    thead { display: table-header-group; } /* Repeat headers on new pages */
                    tfoot { display: table-footer-group; } /* Repeat footers on new pages */
                </style>
            </head>
            <body>
                <h2>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø±Ø§Ø³Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© - Ø§Ù„ÙØªØ±Ø© ${currentPeriod}</h2>
                ${finalTableHtml}
                <h3>Ø§Ù„Ø­Ø±Ø§Ø³ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠÙˆÙ†</h3>
                ${reserveTableHtml}
            </body>
            </html>
        `);
        printWindow.document.close();
        printWindow.focus();
        printWindow.print();
        setStatusMessage(MESSAGES.PRINT_OPEN, "success");
    }

    function clearCacheAndLocalStorage() {
        if (confirm(MESSAGES.CLEAR_CACHE_CONFIRM)) {
            localStorage.clear();
            allGuards = [];
            baseGuards = [];
            distributions = {};
            currentPeriod = 1;
            // Updated to use the new variable name
            globalFixedAssignments = {}; 
            
            document.getElementById(IDS.ROOM_COUNT).value = 5;
            document.getElementById(IDS.GUARDS_PER_ROOM).value = 3;
            initializePeriodSelect();

            document.getElementById(IDS.FINAL_GUARDS_TABLE).innerHTML = '';
            document.getElementById(IDS.RESERVE_GUARDS_TABLE).innerHTML = '';
            document.getElementById(IDS.PRINT_BTN).style.display = "none";
            
            // Clear filter inputs as well
            document.getElementById(IDS.SEARCH_GUARD_INPUT).value = "";
            document.getElementById(IDS.FILTER_RANK).value = "";
            document.getElementById(IDS.FILTER_SUBJECT).value = "";
            document.getElementById(IDS.FILTER_INSTITUTION).value = "";

            updateGuardsTable();
            populateFilterOptions(); // Re-populate filter options after clearing
            
            setStatusMessage(MESSAGES.CLEAR_CACHE_SUCCESS, "success");
            
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }
    }

    // Function to add a new guard manually
    function addNewGuard() {
        const name = document.getElementById(IDS.NEW_GUARD_NAME).value.trim();
        const subject = document.getElementById(IDS.NEW_GUARD_SUBJECT).value.trim();
        const rank = document.getElementById(IDS.NEW_GUARD_RANK).value.trim();
        const institution = document.getElementById(IDS.NEW_GUARD_INSTITUTION).value.trim();

        if (!name || !subject) {
            setStatusMessage(MESSAGES.ADD_GUARD_ERROR, 'error');
            return;
        }

        const newGuard = {
            "Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ù„Ù‚Ø¨": name,
            "Ø§Ù„Ù…Ø§Ø¯Ø©": subject,
            "Ø§Ù„Ø±ØªØ¨Ø©": rank,
            "Ø§Ù„Ù…Ø¤Ø³Ø³Ø©": institution,
            "Ø§Ù„Ù‚Ø§Ø¹Ø©": "",
            "Ø±Ø¦ÙŠØ³ÙŠ": false,
            "Ù…Ø¹ÙÙ‰": false,
            "Ø§Ø­ØªÙŠØ§Ø·ÙŠ": false
        };

        allGuards.push(newGuard);
        baseGuards.push(newGuard); // Also add to baseGuards for reset purposes
        updateGuardsTable(); // Refresh the table
        saveCurrentDistribution(); // Save the updated list of guards
        setStatusMessage(MESSAGES.ADD_GUARD_SUCCESS, 'success');

        // Clear input fields
        document.getElementById(IDS.NEW_GUARD_NAME).value = '';
        document.getElementById(IDS.NEW_GUARD_SUBJECT).value = '';
        document.getElementById(IDS.NEW_GUARD_RANK).value = '';
        document.getElementById(IDS.NEW_GUARD_INSTITUTION).value = '';
        populateFilterOptions(); // Update filter options after adding a new guard
    }
</script>

</body>
</html>